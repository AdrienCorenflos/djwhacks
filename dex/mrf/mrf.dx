'# mrf.dx
## Simulate a quartic MRF using parallel Metropolis-Hastings MCMC on a comonadic image

'### Comonadic pointed image

struct PImage(r, c, a) =
  row: r
  col: c
  im: r=>c=>a

def blank_pim(rows: Nat, cols: Nat) -> PImage(Fin rows, Fin cols, Float) =
  bi = for i:(Fin rows). for j:(Fin cols). 0.0
  PImage.new(0@(Fin rows), 0@(Fin cols), bi)

blank_pim(2, 3)

blank_pim(3, 4)

init = blank_pim(2, 3)

init



-- periodic boundary conditions
def move(pim: PImage(r, c, a), rd: Int, cd: Int) -> PImage(r, c, a) given (r|Ix, c|Ix, a) =
  rows = size r
  cols = size c
  rNew = mod (n_to_i (ordinal pim.row) + rd) (n_to_i rows)
  cNew = mod (n_to_i (ordinal pim.col) + cd) (n_to_i cols)
  PImage.new((unsafe_i_to_n rNew)@r, (unsafe_i_to_n cNew)@c, pim.im)
  
def neighbours(pim: PImage(r, c, a)) -> Fin 4 => PImage(r, c, a) given (r|Ix, c|Ix, a|Data) =
  [move(pim, 0, 1), move(pim, 1, 0), move(pim, -1, 0), move(pim, 0, -1)]

def extract(pim: PImage(r, c, a)) -> a given (r, c, a) =
  pim.im[pim.row, pim.col]

def cobind(pim: PImage(r, c, a), f: (PImage(r, c, a)) -> b) -> PImage(r, c, b)
    given (r|Ix, c|Ix, a, b) =
  p2 = for i:r. for j:c. f(PImage.new(i, j, pim.im))
  PImage.new(pim.row, pim.col, p2)

def cobindr(pim: PImage(r, c, a), f: (PImage(r, c, a), Key) -> b, k: Key) -> PImage(r, c, b)
    given (r|Ix, c|Ix, a, b) =
  -- TODO: Need to split keys!
  p2 = for i:r. for j:c. f(PImage.new(i, j, pim.im), k)
  PImage.new(pim.row, pim.col, p2)

'### Kernel for a quartic field

-- coupling constant
w = 0.45

-- potential function
def v(l: Float, x: Float) -> Float = l*x - 2*x*x + x*x*x*x

def mhKern(pi: PImage(r, c, Float), k: Key) -> Float given (r|Ix, c|Ix) =
  [k1, k2] = split_key k
  sn = sum $ map extract $ neighbours pi
  x0 = extract pi
  x1 = x0 + randn k1 -- tune this
  lap = v(-w*sn, x0) - v(-w*sn, x1)
  if ((log $ rand k2) < lap)
    then x1
    else x0

-- TODO: Need odd/even kernels

'### Markov chain utilities

def step_n(n: Nat, kern: (s, Key) -> s,
    state: s, k: Key) -> s given (s|Data) =
  yield_state state \st.
    for i:(Fin n).
      st := kern (get st) (ixkey k i)

def markov_chain(init: s, kern: (s, Key) -> s, its: Nat,
    k: Key) -> Fin its => s given (s|Data) =
  st <- with_state init
  for i:(Fin its).
    x = kern (get st) (ixkey k i)
    st := x
    x

'### Simulate the quartic MRF

its = 5

def kern(pim: PImage(r, c, Float), k: Key) -> PImage(r, c, Float) given (r|Ix, c|Ix) =
  cobindr(pim, mhKern, k)

blank_pim(2, 3)

init = blank_pim(2, 3)

init



chain = markov_chain(init, kern, its, new_key 42)

chain

:t chain

c0 = chain[0@(Fin its)]
pixels(c0)
c1 = chain[1@(Fin its)]
pixels(c1)

im_chain = for i:(Fin its). chain[i].im
im_chain
:t im_chain

pix_chain : (Fin its)=>(Fin rows)=>(Fin cols)=>Float = for i:(Fin its).
  im = im_chain[i] :: Image(Float)
  MkIm(r, c, px) : Image(Float) = im
  px
pix_chain
:t pix_chain

'#### Sandpit...

t1 = [[1, 2], [3, 4], [5, 6]]
t1
sum t1
sum $ sum t1
i1 = MkIm(3, 2, t1)
i1

i2 = blank_im 3 5
i2

pix_type i2

blank_pim 3 3

pi1 = PImage.new(0, 1, i1)
pi1
extract pi1
move pi1 (-1) 0
neighbours pi1
map extract $ neighbours pi1

def kern1(pim: PImage(Nat)) -> Float =
  s = sum $ map extract $ neighbours pim
  (n_to_f s) / 4.0

cobind pi1 kern1

pix = pixels(pi1)
pix
pix[1@(Fin 3)]

'End of the sandpit.





-- eof


